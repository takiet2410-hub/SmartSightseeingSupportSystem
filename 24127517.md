# 1. Detailed Decomposition of the Metadata Extractor

The goal of this module is to receive a batch of raw image files and return a list of standardized Python/JSON objects (called `PhotoObject`), where each object contains the critical metadata for subsequent steps.

# 2. Define the `PhotoObject` Data Structure

This is the most crucial step to ensure subsequent modules can function.

- **To-do:** Create a `class` for `PhotoObject`.
    
- **Required Fields:**
    
    - `image_id`: A unique ID (e.g., `uuid` or temporary filename).
        
    - `original_filename`: The original filename uploaded by the user (e.g., `IMG_1234.jpg`).
        
    - `temp_file_path`: The path to the temporary image file on the server (so subsequent module can read and analyze it for blur).
        
    - `timestamp_utc`: A `datetime` object standardized to UTC (or `None` if missing).
        
    - `gps_coordinates`: A `dict` containing `{"lat": float, "lon": float}` (or `None` if missing).
        
    - `metadata_status`: A flag indicating the status (e.g., `"OK"`, `"MISSING_TIMESTAMP"`, `"MISSING_GPS"`, `"CORRUPT"`).
        

# 3. Build the Batch Processing Function

It receives the list of files from the API and coordinates the work.

- **To-do:** Write the function `def process_image_batch(uploaded_files):`
    
- **Internal Steps:**
    
    1. Initialize an empty list: `photo_objects_list = []`.
        
    2. Loop through each `file` in `uploaded_files`.
        
    3. Save the `file` to a temporary directory on the server and get its `temp_file_path`.
        
    4. Call the `extract_single_image_metadata(temp_file_path, file.filename)` function.
        
    5. `Append` the returned `PhotoObject` to the `photo_objects_list`.
        
    6. `Return photo_objects_list`.

# 4. Build the Single File Processor

This function handles the logic for each individual image file.
	
- **To-do:** Write the function `def extract_single_image_metadata(file_path, original_name):`
    
- **Internal Steps:**
    
    1. Initialize a default `PhotoObject` with its `image_id`, `original_filename`, and `temp_file_path`.
        
    2. Open the file using `exifread.process_file(f)`.
        
    3. Use a `try...except` block to catch errors (e.g., corrupt file, not an image). If an error occurs, set `metadata_status = "CORRUPT"` and `return photo_object`.
        
    4. Call the `parse_timestamp(exif_tags)` function (defined in 4.1). Assign the result to `photo_object.timestamp_utc`.
        
    5. Call the `parse_gps(exif_tags)` function (defined in 4.2). Assign the result to `photo_object.gps_coordinates`.
        
    6. Update `metadata_status` based on the results (e.g., if `timestamp_utc` is `None` and `gps_coordinates` is `None`, set status to `"MISSING_BOTH"`).
        
    7. `Return photo_object`.
        

## 4.1. Sub-module: Extract & Standardize Timestamp

This function focuses on one job: taking messy Timestamp data from EXIF and returning a standard UTC `datetime` object.

- **To-do:** Write the function `def parse_timestamp(exif_tags):`
    
- **Internal Steps:**
    
    1. Attempt to get the value from priority tags: `EXIF DateTimeOriginal`, then `EXIF DateTimeDigitized`, and finally `Image DateTime`.
        
    2. If no tag is found, `return None`.
        
    3. If found, the value will be a string (e.g., `"2025:10:30 15:00:00"`).
        
    4. Use `datetime.strptime()` to parse this string into a `datetime` object. (A common format is `"%Y:%m:%d %H:%M:%S"`).
        
    5. **Important:** This `datetime` object is _naive_ (it has no timezone info). A strategy is needed (e.g., assume local time and convert to UTC, or temporarily treat it as UTC). For simplicity, just return the parsed datetime.
        
    6. `Return` the standardized `datetime` object.
        

## 4.2. Sub-module: Extract & Standardize GPS

This function focuses on converting GPS data (usually in DMS format) to Decimal Degrees.

- **To-do:** Write the function `def parse_gps(exif_tags):`
    
- **Internal Steps:**
    
    1. Check for the _simultaneous_ existence of these tags: `GPS GPSLatitude`, `GPS GPSLongitude`, `GPS GPSLatitudeRef`, `GPS GPSLongitudeRef`.
        
    2. If any tag is missing, `return None`.
        
    3. Get the values (which are in DMS - Degrees, Minutes, Seconds).
        
    4. Write a helper function `dms_to_decimal(dms_values, ref)`:
        
        - Formula: `decimal = degrees + (minutes / 60) + (seconds / 3600)`
            
        - Based on the `ref` ("S" or "W"), multiply the `decimal` by `-1`.
            
    5. Call this helper function for both Latitude and Longitude.
        
    6. `Return {"lat": lat_decimal, "lon": lon_decimal}`.
        