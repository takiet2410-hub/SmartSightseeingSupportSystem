# 1. Detailed Decomposition of the Metadata Extractor

The goal of this module is to receive a batch of raw image files and return a list of standardized Python/JSON objects (called `PhotoObject`), where each object contains the critical metadata for subsequent steps.

# 2. Libraries, APIs, and Tools

This section lists the specific technologies required to build and run this module. 

## 2.1. Libraries (Python)

- **`exifread`**: The main library used to read metadata (Timestamp, GPS) from the image files.
- **`os`**: Built-in library used to get the "File Modification Time" as a fallback. 
- **`datetime`**: Built-in library used to parse date strings and create standardized `datetime` objects. 
- **`uuid`**: Built-in library used to generate the unique `image_id` for each `PhotoObject`. 
- **`tempfile`**: Built-in library to save the uploaded files to a temporary path on the server. 

## 2.2. APIs

- **`POST /create-album` (Internal API):** This module is called *by* this API endpoint. This endpoint is responsible for receiving the photos.

## 2.3. Tools

- **`FastAPI`**: The tool used to *build* the `POST /create-album` API endpoint. 
- **`Python 3.10+`**: The required version of Python for the backend. 

# 3. Define the `PhotoObject` Data Structure

This is the most crucial step to ensure subsequent modules can function.

- **To-do:** Create a `class` for `PhotoObject`.
    
- **Required Fields:**
    
    - `image_id`: A unique ID (e.g., `uuid` or temporary filename).
        
    - `original_filename`: The original filename uploaded by the user (e.g., `IMG_1234.jpg`).
        
    - `temp_file_path`: The path to the temporary image file on the server (so subsequent module can read and analyze it for blur).
        
    - `timestamp_utc`: A `datetime` object standardized to UTC (or `None` if missing).
        
    - `gps_coordinates`: A `dict` containing `{"lat": float, "lon": float}` (or `None` if missing).
        
    - `metadata_status`: A flag indicating the status (e.g., `"OK"`, `"MISSING_TIMESTAMP"`, `"MISSING_GPS"`, `"MISSING_BOTH"`, `"CORRUPT"`, `"FALLBACK_FILE_MODIFICATION_DATE"`).

# 4. Build the Batch Processing Function

It receives the list of files from the API and coordinates the work.

- **To-do:** Write the function `def process_image_batch(uploaded_files):`
    
- **Internal Steps:**
    
    1. Initialize an empty list: `photo_objects_list = []`.
        
    2. Loop through each `file` in `uploaded_files`.
        
    3. Save the `file` to a temporary directory on the server and get its `temp_file_path`.
        
    4. Call the `extract_single_image_metadata(temp_file_path, file.filename)` function.
        
    5. `Append` the returned `PhotoObject` to the `photo_objects_list`.
        
    6. `Return photo_objects_list`.

# 5. Build the Single File Processor

This function handles the logic for each individual image file.
	
- **To-do:** Write the function `def extract_single_image_metadata(file_path, original_name):`
    
- **Internal Steps:**
    
    1. Initialize a default `PhotoObject` with its `image_id`, `original_filename`, and `temp_file_path`.
        
    2. Open the file using `exifread.process_file(f)`.
        
    3. Use a `try...except` block to catch errors (e.g., corrupt file, not an image). If an error occurs, set `metadata_status = "CORRUPT"` and `return photo_object`.
        
    4. Call the `parse_timestamp(exif_tags)` function (defined in 5.1). Assign the result to `photo_object.timestamp_utc`.
        
    5. Call the `parse_gps(exif_tags)` function (defined in 5.2). Assign the result to `photo_object.gps_coordinates`.
        
    6. Update `metadata_status` based on the results (e.g., if `timestamp_utc` is `None` and `gps_coordinates` is `None`, set status to `"MISSING_BOTH"`).
        
    7. `Return photo_object`.

## 5.1. Sub-module: Extract & Standardize Timestamp

This function focuses on one job: taking messy Timestamp data from EXIF and returning a standard UTC `datetime` object.

- **To-do:** Write the function `def parse_timestamp(exif_tags):`
    
- **Internal Steps:**
    
    1. Attempt to get the value from priority tags: `EXIF DateTimeOriginal`, then `EXIF DateTimeDigitized`, and finally `Image DateTime`.
        
    2. If no tag is found, `return None`.
        
    3. If found, the value will be a string (e.g., `"2025:10:30 15:00:00"`).
        
    4. Use `datetime.strptime()` to parse this string into a `datetime` object. (A common format is `"%Y:%m:%d %H:%M:%S"`).
        
    5. **Important:** This `datetime` object is _naive_ (it has no timezone info). A strategy is needed (e.g., assume local time and convert to UTC, or temporarily treat it as UTC). For simplicity, just return the parsed datetime.
        
    6. `Return` the standardized `datetime` object.

## 5.2. Sub-module: Extract & Standardize GPS

This function focuses on converting GPS data (usually in DMS format) to Decimal Degrees.

- **To-do:** Write the function `def parse_gps(exif_tags):`
    
- **Internal Steps:**
    
    1. Check for the _simultaneous_ existence of these tags: `GPS GPSLatitude`, `GPS GPSLongitude`, `GPS GPSLatitudeRef`, `GPS GPSLongitudeRef`.
        
    2. If any tag is missing, `return None`.
        
    3. Get the values (which are in DMS - Degrees, Minutes, Seconds).
        
    4. Write a helper function `dms_to_decimal(dms_values, ref)`:
        
        - Formula: `decimal = degrees + (minutes / 60) + (seconds / 3600)`
            
        - Based on the `ref` ("S" or "W"), multiply the `decimal` by `-1`.
            
    5. Call this helper function for both Latitude and Longitude.
        
    6. `Return {"lat": lat_decimal, "lon": lon_decimal}`.

# 6. Build "Fallback" Logic

This function is called _after_ `process_image_batch` is complete, to handle images that were missing data.

- **To-do:** Write the function `def apply_missing_data_logic(photo_objects_list):`
    
- **Internal Steps:**
    
    1. Iterate through each `photo` in `photo_objects_list`.
        
    2. **Handle missing Timestamp:** If `photo.timestamp_utc is None`:
        
        - Attempt to read the "File Modification Time" from `photo.temp_file_path` (using `os.path.getmtime`).
            
        - Convert this value to a UTC `datetime` and assign it to `photo.timestamp_utc`.
            
        - Update `photo.metadata_status` to `"FALLBACK_FILE_MODIFICATION_DATE"` to know this is inferred data, not from EXIF.
            
    3. **Handle missing GPS:** If `photo.gps_coordinates is None`:
        
        - For now, just ensure the `metadata_status` reflects this (e.g., `"MISSING_GPS"`).
            
        - (In the future, this is where GPS "inference" logic could be triggered, e.g., if other photos from the same day have GPS, this one might be nearby).
            
    4. `Return` the updated `photo_objects_list`.

# Data Flow

This decomposition creates a clear data flow, preparing for Filtering, Clustering and Curation Logic Module:

1. The **API** receives `list_of_raw_files`.
    
2. The **API** calls `process_image_batch(list_of_raw_files)`.
    
    - Inside, `process_image_batch` loops and calls `extract_single_image_metadata` for each file.
        
    - `extract_single_image_metadata` uses `parse_timestamp` and `parse_gps`.
        
    - The result returned is `unhandled_photo_list`.
        
3. The **API** calls `apply_missing_data_logic(unhandled_photo_list)`.
    
    - The result returned is `final_photo_list`.
        
4. `final_photo_list` (a list of `PhotoObject`) is passed on to next Module **(Filtering, Clustering and Curation Logic)**.

Now, Module Filtering, Clustering and Curation Logic can iterate through `final_photo_list` and, for each `PhotoObject`, it can:

- Read `photo.temp_file_path` to analyze for blurriness/darkness.
    
- If the photo is "good," keep the `PhotoObject` in the list.
    
- If the photo is "bad," remove the `PhotoObject` from the list.